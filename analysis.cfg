# Config for KataGo C++ Analysis engine, i.e. "./katago.exe analysis"

# Example config for C++ (non-python) analysis engine

# SEE NOTES ABOUT PERFORMANCE AND MEMORY USAGE IN gtp_example.cfg
# SEE NOTES ABOUT numSearchThreads AND OTHER IMPORTANT PARAMS BELOW!

# Logs------------------------------------------------------------------------------------

# Where to output log?
logDir = analysis_logs  # Each run of KataGo will log to a separate file in this dir
# logDirDated = analysis_logs  # Use this instead of logDir to also write separate dated subdirs
# logFile = analysis.log  # Use this instead of logDir to just specify a single file directly
# logToStderr = true      # Echo everything output to log file to stderr as well
# logAllRequests = false  # Log all input lines received to the analysis engine.
# logAllResponses = false # Log all lines output to stdout from the analysis engine.
# logErrorsAndWarnings = true # Log all lines output to stdout from the analysis engine that are errors and warnings
# logSearchInfo = false   # Log debug info for every search performed

# Report a warning whenever a query contains a field that is unused. Helps to guard against
# typos when writing code that queries the analysis engine.
# warnUnusedFields = true

# Analysis------------------------------------------------------------------------------------

# Controls the number of moves after the first move in a variation.
# analysisPVLen = 15

# Report winrates for analysis as (BLACK|WHITE|SIDETOMOVE).
reportAnalysisWinratesAs = BLACK

# Larger values will make KataGo explore the top move(s) less deeply and accurately,\n# but explore and give evaluations to a greater variety of moves.\n# An extreme value like 1 will distribute many playouts across every move on the board, even very bad moves.\n# NOTE: defaults to 0.04, under the presumption that the analysis engine will be used mainly for analysis.\n# If you are intending to use the analysis engine to also play games and you want to maximize playing strength,\n# set this to 0.0 either in this config or in the overrides.\n# wideRootNoise = 0.04

# Try to limit the effect of possible bad or bogus move sequences in the\n# history leading to this position from affecting KataGo's move predictions.\n# ignorePreRootHistory = true

# Bot behavior---------------------------------------------------------------------------------------\n\n# Handicap -------------\n\n# Assume that if black makes many moves in a row right at the start of the game, then the game is a handicap game.\n# This is necessary on some servers and for some GUIs and also when initializing from many SGF files, which may\n# set up a handicap game using repeated GTP "play" commands for black rather than GTP "place_free_handicap" commands.\n# However, it may also lead to incorrect understanding of komi if whiteHandicapBonus is used and a server does NOT\n# have such a practice.\n# Defaults to true! Uncomment and set to false to disable this behavior.\n# assumeMultipleStartingBlackMovesAreHandicap = true

# Passing and cleanup -------------\n\n# Make the bot never assume that its pass will end the game, even if passing would end and "win" under Tromp-Taylor rules.\n# Usually this is a good idea when using it for analysis or playing on servers where scoring may be implemented non-tromp-taylorly.\n# Defaults to true! Uncomment and set to false to disable this.\n# conservativePass = true

# When using territory scoring, self-play games continue beyond two passes with special cleanup\n# rules that may be confusing for human players. This option prevents the special cleanup phases from being\n# reachable when using the bot for GTP play.\n# Defaults to true! Uncomment and set to false if you want KataGo to be able to enter special cleanup.\n# For example, if you are testing it against itself, or against another bot that has precisely implemented the rules\n# documented at https://lightvector.github.io/KataGo/rules.html\n# preventCleanupPhase = true

# Experimental feature - useEvalCache is false by default in v1.16.4,\n# may become true by default in later versions.\n# If set to true, will remember the evaluations of any node that got\n# at least evalCacheMinVisits many visits, and on future searches\n# that encounter that exact position, until KataGo is restarted or\n# the cache is cleared, can bias future searches based on that eval.\n# In particular, if you are interactively analyzing and help KataGo solve\n# a blind spot by playing down a variation with it, it can remember and\n# become more capable of solving that variation from earlier as well.\n# useEvalCache = false
# evalCacheMinVisits = 100

# Search limits-----------------------------------------------------------------------------------\n\n# By default, if NOT specified in an individual request, limit maximum number of root visits per search to this much\nmaxVisits = 500
# If provided, cap search time at this many seconds\n# maxTime = 60

# Search threads, batching, GPUs--------------------------------------------------------------------------\n\n# Try a configuration like this if you only expect the engine to be handling a few queries at a time and you want\n# individual queries to return more quickly, and are okay with the results being a bit lower-quality and the overall\n# peak throughput on queries to be lower.\nnumAnalysisThreads = 2
numSearchThreadsPerAnalysisThread = 16

# Try a configuration like this if you expect to be sending large numbers of queries at a time, and want to maximize\n# total throughput and also the evaluation quality of all the queries and you never care about the response latency\n# of the individual queries, only the throughput as a whole.\n# numAnalysisThreads = 32\n# numSearchThreadsPerAnalysisThread = 1

# You will want to increase one or both numbers if you have a powerful GPU, and possibly decrease one or both if you\n# have a very weak GPU, and play with the balance between them depending on your use case.\n# Read the explanation below to understand how to set these parameters:\n\n# EXPLANATION:\n# numAnalysisThreads:                 the number of POSITIONS to be able to search in parallel.\n# numSearchThreadsPerAnalysisThread:  the number of threads to use in the tree search for EACH position.\n# (older analysis configs might just have 'numSearchThreads', this is an alias for 'numSearchThreadsPerAnalysisThread')\n\n# Therefore, the total number of search threads that may be active at a given time could be as large as the product:\n# numAnalysisThreads * numSearchThreadsPerAnalysisThread\n\n# Searching more positions in parallel is more efficient since the different threads aren't conflicting with each\n# other on the same MCTS search tree. Using multiple threads on the same search will both make things slower\n# and weaken the search (holding playouts fixed) due to out of date statistics on nodes and suboptimal exploration,\n# although the cost is minor for only 2,4,8 threads.\n\n# So unlike in GTP, which only ever searches one position at a time and where therefore you might as well make\n# numSearchThreads as large as possible, in the analysis engine you often want you often want to keep numSearchThreads small,\n# and instead parallelize across positions, so you can reduce conflict between threads and improve the overall throughput\n# and strength of the search.\n\n# But obviously you only get the benefit of parallelization across positions when you actually have lots of positions\n# that you are querying at once! For example, setting numAnalysisThreads = 8 is useless if you only ever send one or two\n# queries at a time!\n\n# Therefore:\n# * If you plan to use the analysis engine only for batch processing large numbers of positions,\n#   it's preferable to numSearchThreadsPerAnalysisThread to only a small number (e.g. 1,2,4) and use a higher numAnalysisThreads.\n# * But if you sometimes plan to query the analysis engine for single positions, or otherwise in smaller quantities\n#   than -num-analysis-threads, or if you plan to be user-interactive such that the response time on some individual\n#   analysis requests is important to keep low, then set numSearchThreadsPerAnalysisThread to a larger number and use\n#   a lower numAnalysisThreads. That way, individual searches complete faster due to having more threads on each one.\n\n# For 19x19 boards, weaker GPUs probably want a TOTAL number of threads (numAnalysisThreads * numSearchThreadsPerAnalysisThread)\n# between 4 and 32. Mid-tier GPUs probably between 16 and 64. Strong GPUs probably between 32 and 256.\n# But there's no substitute for experimenting and seeing what's best for your hardware and your usage case.\n\n# Keep in mind that the number of threads you want does NOT necessarily have much to do with how many cores you have on your\n# system. The optimal may easily exceed the number of cores! GPU batching is (usually) the dominant consideration.\n\n# -------------\n\n# nnMaxBatchSize is the max number of positions to send to a single GPU at once. Generally, it should be the case that:\n# (number of GPUs you will use * nnMaxBatchSize) >= (numSearchThreads * num-analysis-threads)\n# That way, when each threads tries to request a GPU eval, your batch size summed across GPUs is large enough to handle them\n# all at once. However, it can be sensible to set this a little smaller if you are limited on GPU memory,\n# too large a number may fail if the GPU doesn't have enough memory.\nnnMaxBatchSize = 64

# Uncomment and set these smaller if you are going to use the analysis engine EXCLUSIVELY for smaller boards (or plan to\n# run multiple instances, with some instances only handling smaller boards). It should improve performance.\n# It may also mean you can use more threads profitably.\n# maxBoardXSizeForNNBuffer = 19\n# maxBoardYSizeForNNBuffer = 19

# Uncomment and set this to true if you are going to use the analysis engine EXCLUSIVELY for exactly the board size\n# specified by maxBoardXSizeForNNBuffer and maxBoardYSizeForNNBuffer. It may slightly improve performance on some GPUs.\n# requireMaxBoardSize = true

# TO USE MULTIPLE GPUS:\n# Uncomment and set this to the number of GPUs you have and/or would like to use...\n# AND if it is more than 1, uncomment the appropriate CUDA or OpenCL section below.\n# numNNServerThreadsPerModel = 1

# Other General GPU Settings-------------------------------------------------------------------------------\n\n# Cache up to 2 ** this many neural net evaluations in case of transpositions in the tree.\nnnCacheSizePowerOfTwo = 23
# Size of mutex pool for nnCache is 2 ** this\nnnMutexPoolSizePowerOfTwo = 17
# Randomize board orientation when running neural net evals?\nnnRandomize = true


# TENSORRT GPU settings--------------------------------------\n# These only apply when using the TENSORRT version of KataGo.\n\n# IF USING ONE GPU: optionally uncomment and change this if the GPU you want to use turns out to be not device 0\n# trtDeviceToUse = 0

# IF USING TWO GPUS: Uncomment these two lines (AND set numNNServerThreadsPerModel above):\n# trtDeviceToUseThread0 = 0  # change this if the first GPU you want to use turns out to be not device 0\n# trtDeviceToUseThread1 = 1  # change this if the second GPU you want to use turns out to be not device 1

# IF USING THREE GPUS: Uncomment these three lines (AND set numNNServerThreadsPerModel above):\n# trtDeviceToUseThread0 = 0  # change this if the first GPU you want to use turns out to be not device 0\n# trtDeviceToUseThread1 = 1  # change this if the second GPU you want to use turns out to be not device 1\n# trtDeviceToUseThread2 = 2  # change this if the third GPU you want to use turns out to be not device 2

# You can probably guess the pattern if you have four, five, etc. GPUs.


# CUDA-specific GPU settings--------------------------------------\n# These only apply when using the CUDA version of KataGo.\n\n# IF USING ONE GPU: optionally uncomment and change this if the GPU you want to use turns out to be not device 0\n# cudaDeviceToUse = 0

# IF USING TWO GPUS: Uncomment these two lines (AND set numNNServerThreadsPerModel above):\n# cudaDeviceToUseThread0 = 0  # change this if the first GPU you want to use turns out to be not device 0\n# cudaDeviceToUseThread1 = 1  # change this if the second GPU you want to use turns out to be not device 1

# IF USING THREE GPUS: Uncomment these three lines (AND set numNNServerThreadsPerModel above):\n# cudaDeviceToUseThread0 = 0  # change this if the first GPU you want to use turns out to be not device 0\n# cudaDeviceToUseThread1 = 1  # change this if the second GPU you want to use turns out to be not device 1\n# cudaDeviceToUseThread2 = 2  # change this if the third GPU you want to use turns out to be not device 2

# You can probably guess the pattern if you have four, five, etc. GPUs.\n\n# KataGo will automatically use FP16 or not based on the compute capability of your NVIDIA GPU. If you\n# want to try to force a particular behavior though you can uncomment these lines and change them\n# to "true" or "false". E.g. it's using FP16 but on your card that's giving an error, or it's not using\n# FP16 but you think it should.\n# cudaUseFP16 = auto\n# cudaUseNHWC = auto


# ------------------------------\n# Metal GPU settings\n# ------------------------------\n# These only apply when using the METAL version of KataGo.\n\n# For one Metal instance: KataGo will automatically use the default device.\n# metalDeviceToUse = 0

# For two Metal instance: Uncomment these options, AND set numNNServerThreadsPerModel = 2 above.\n# This will create two Metal instances, best overlapping the GPU and CPU execution.\n# metalDeviceToUseThread0 = 0\n# metalDeviceToUseThread1 = 1

# The pattern continues for additional Metal instances.\n\n\n# OpenCL-specific GPU settings--------------------------------------\n# These only apply when using the OpenCL version of KataGo.\n\n# Uncomment to tune OpenCL for every board size separately, rather than only the largest possible size\n# openclReTunePerBoardSize = true

# IF USING ONE GPU: optionally uncomment and change this if the best device to use is guessed incorrectly.\n# The default behavior tries to guess the 'best' GPU or device on your system to use, usually it will be a good guess.\n# openclDeviceToUse = 0

# IF USING TWO GPUS: Uncomment these two lines and replace X and Y with the device ids of the devices you want to use.\n# It might NOT be 0 and 1, some computers will have many OpenCL devices. You can see what the devices are when\n# KataGo starts up - it should print or log all the devices it finds.\n# (AND also set numNNServerThreadsPerModel above)\n# openclDeviceToUseThread0 = X\n# openclDeviceToUseThread1 = Y

# IF USING THREE GPUS: Uncomment these three lines and replace X and Y and Z with the device ids of the devices you want to use.\n# It might NOT be 0 and 1 and 2, some computers will have many OpenCL devices. You can see what the devices are when\n# KataGo starts up - it should print or log all the devices it finds.\n# (AND also set numNNServerThreadsPerModel above)\n# openclDeviceToUseThread0 = X\n# openclDeviceToUseThread1 = Y
# openclDeviceToUseThread2 = Z

# You can probably guess the pattern if you have four, five, etc. GPUs.\n\n# KataGo will automatically use FP16 or not based on testing your GPU during tuning. If you\n# want to try to force a particular behavior though you can uncomment this lines and change it\n# to "true" or "false". This is a fairly blunt setting - more detailed settings are testable\n# by rerunning the tuner with various arguments.\n# openclUseFP16 = auto


# Eigen-specific settings--------------------------------------\n# These only apply when using the Eigen (pure CPU) version of KataGo.\n\n# This is the number of CPU threads for evaluating the neural net on the Eigen backend.\n# It defaults to min(numAnalysisThreads * numSearchThreadsPerAnalysisThread, numCPUCores).\n# numEigenThreadsPerModel = X


# Misc Behavior --------------------\n\n# If the board is symmetric, search only one copy of each equivalent move. Attempts to also account for ko/superko, will not theoretically perfect for superko.\n# Uncomment and set to false to disable this.\n# rootSymmetryPruning = true

# Uncomment and set to true to make KataGo avoid a particular joseki that some KataGo nets misevaluate,\n# and also to improve opening diversity versus some particular other bots that like to play it all the time.\n# avoidMYTDaggerHack = false

# Have KataGo mildly prefer to avoid playing the same joseki in every corner of the board.\n# Uncomment to set to a specific value. A small value like 0.005 should produce already a noticeable behavior change.\n# avoidRepeatedPatternUtility = 0.0

# Enable some hacks that mitigate rare instances when passing messes up deeper searches.\n# enablePassingHacks = true

# Root move selection and biases------------------------------------------------------------------------------\n# Uncomment and edit any of the below values to change them from their default.\n# Not all of these parameters are applicable to analysis, some are only used for actual play\n\n# Temperature for the early game, randomize between chosen moves with this temperature\n# chosenMoveTemperatureEarly = 0.5\n# Decay temperature for the early game by 0.5 every this many moves, scaled with board size.\n# chosenMoveTemperatureHalflife = 19\n# At the end of search after the early game, randomize between chosen moves with this temperature\n# chosenMoveTemperature = 0.10\n# Subtract this many visits from each move prior to applying chosenMoveTemperature\n# (unless all moves have too few visits) to downweight unlikely moves\n# chosenMoveSubtract = 0\n# The same as chosenMoveSubtract but only prunes moves that fall below the threshold, does not affect moves above\n# chosenMovePrune = 1\n\n# Number of symmetries to sample (WITHOUT replacement) and average at the root\n# rootNumSymmetriesToSample = 1

# Using LCB for move selection?\n# useLcbForSelection = true\n# How many stdevs a move needs to be better than another for LCB selection\n# lcbStdevs = 5.0\n# Only use LCB override when a move has this proportion of visits as the top move\n# minVisitPropForLCB = 0.15

# Internal params------------------------------------------------------------------------------\n# Uncomment and edit any of the below values to change them from their default.\n\n# Scales the utility of winning/losing\n# winLossUtilityFactor = 1.0\n# Scales the utility for trying to maximize score\n# staticScoreUtilityFactor = 0.10\n# dynamicScoreUtilityFactor = 0.30\n# Adjust dynamic score center this proportion of the way towards zero, capped at a reasonable amount.\n# dynamicScoreCenterScale = 0.75\n# The utility of getting a "no result" due to triple ko or other long cycle in non-superko rulesets (-1 to 1)\n# noResultUtilityForWhite = 0.0\n# The number of wins that a draw counts as, for white. (0 to 1)\n# drawEquivalentWinsForWhite = 0.5

# Exploration constant for mcts\n# cpuctExploration = 1.0\n# cpuctExplorationLog = 0.45

# Parameters that control exploring more in volatile positions, exploring less in stable positions.\n# cpuctUtilityStdevPrior = 0.40\n# cpuctUtilityStdevPriorWeight = 2.0\n# cpuctUtilityStdevScale = 0.85

# FPU reduction constant for mcts\n# fpuReductionMax = 0.2\n# rootFpuReductionMax = 0.1\n# fpuParentWeightByVisitedPolicy = true

# Parameters that control weighting of evals based on the net's own self-reported uncertainty.\n# useUncertainty = true\n# uncertaintyExponent = 1.0\n# uncertaintyCoeff = 0.25

# Explore using optimistic policy\n# rootPolicyOptimism = 0.2\n# policyOptimism = 1.0

# Amount to apply a downweighting of children with very bad values relative to good ones\n# valueWeightExponent = 0.25

# Slight incentive for the bot to behave human-like with regard to passing at the end, filling the dame,\n# not wasting time playing in its own territory, etc, and not play moves that are equivalent in terms of\n# points but a bit more unfriendly to humans.\n# rootEndingBonusPoints = 0.5

# Make the bot prune useless moves that are just prolonging the game to avoid losing yet\n# rootPruneUselessMoves = true

# Apply bias correction based on local pattern keys\n# subtreeValueBiasFactor = 0.45\n# subtreeValueBiasWeightExponent = 0.85

# Use graph search rather than tree search - identify and share search for transpositions.\n# useGraphSearch = true

# How much to shard the node table for search synchronization\n# nodeTableShardsPowerOfTwo = 16
# How many virtual losses to add when a thread descends through a node\n# numVirtualLossesPerThread = 1

# Improve the quality of evals under heavy multithreading\n# useNoisePruning = true


# Avoid SGF Patterns ------------------------------------------------------------------------------\n# The parameters in this section provide a powerful way to customize KataGo to avoid moves that follow specific patterns\n# based on a set of provided SGF files loaded upon startup. Uncomment them to use this feature.\n# Additionally, if the SGF file contains the string %SKIP% in a comment on a move, that move will be ignored for this purpose.\n\n# Load sgf files from this directory when the engine is started (ONLY on startup, will not reload unless engine is restarted)\n# avoidSgfPatternDirs = path/to/directory/with/sgfs/\n# You can also surround the file path in double quotes if the file path contains trailing spaces or hash signs.\n# Within double quotes, backslashes are escape characters.\n# avoidSgfPatternDirs = "path/to/directory/with/sgfs/"

# Penalize this much utility per matching move.\n# Set this negative if you instead want to make KataGo favor the SGF patterns instead of penalizing it!\n# This number does not need to be large, even 0.001 will make a difference. Too-large values may lead to bad play.\n# avoidSgfPatternUtility = 0.001

# Optional - load only the newest this many files\n# avoidSgfPatternMaxFiles = 20

# Optional - Penalty is multiplied by this per each older SGF file, so that old sgf files matter less than newer ones.\n# avoidSgfPatternLambda = 0.90

# Optional - pay attention only to moves that were made by players with this name.\n# For example you can set it to the name that your bot's past games will show up as in the SGF, so that the bot will only avoid repeating\n# moves that itself made in past games, not the moves that its opponents made.\n# avoidSgfPatternAllowedNames = my-ogs-bot-name1,my-ogs-bot-name2

# Optional - Ignore any moves in SGF files that occurred before this turn number.\n# avoidSgfPatternMinTurnNumber = 0

# For more avoid patterns:\n# You can also specify a second set of parameters, and a third, fourth, etc by numbering 2,3,4,...\n# avoidSgf2PatternDirs = ...\n# avoidSgf2PatternUtility = ...\n# avoidSgf2PatternMaxFiles = ...\n# avoidSgf2PatternLambda = ...\n# avoidSgf2PatternAllowedNames = ...\n# avoidSgf2PatternMinTurnNumber = ...